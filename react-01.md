# goit-react-hw-01-components

- установка react
  - пустая папка
  - npx create-react-app имя*папки*проекта (или . если в ту же директорию)
- .prettirrc.json
- ничего не пишем в public (уйдёт в продакшн)
- react - ядро react-dom - virtual-dom для браузера react-scripts - абстракция,
  закрывает настройки babel, eslint и т.п.
- scripts
  - eject - для того, чтоб раскрыть все файлы настроек - webpack, babel...
  - start - запускает web-сервер
  - build - запускает в продакшн
- в public/index.html - никогда ничего не писать руками!
  - между тегом <div id="root"></div> будет рендерится наш проек (приходит js и
    react)
- в src/ можно оставить только index.js и запись про React.DOM

---

- создаём элемент виртуального дома (реакт-элемент - самый маленький
  строительный блок реакта)
- сказать, что мы хотим его зарендерить
- реакт превратит его в настоящий элемент (тег) и повесит в DOM
- import React from 'react';
  - прописываем то, что нужно (создание элемента), pfgускаем сервер и видим, что
    к нам приходит объект (потому что мы работаем с виртуальным домом)
  - чтобы перенести с виртуального в настоящий необходимо зарендерить путём
    импорта и запуска ReactDOM.render()
- внутри реакт-файлов мы можем использовать JSX (javascript syntax extension) -
  расширение синтаксиса js
  - это для удобства чтения синтаксиса как обычного html, после чего babel его
    компилирует в привычный формат

---

- создаём карточку
  - пишем объект
  - создаём шаблон, пишется в скобках()
  - рендерим с помощью ReactDOM.render()
- в jsx всё пишется как в html, но передаётся как объект со свойствами
  - динамическое значение подставляется в {} (в js `${}`), наз. JSX-выражение
    - в скобки подставляется просто адрес к свойству <h2>{painting.title}</h2>
    - при большей вложности так же как и в js - больше точек
      {painting.title.subtitle.soname}
    - но вставить можно одно валидное js-выражение, нельзя вставить результат
      2-х ф-ций

--- КОМПОНЕНТЫ -----

- компонент - как БЭМ-блок
- создаём папку components и файл App.js
- закидываем в компонент настройки и он нам выкидывает виртуальный ДОМ (как
  ф-ция)
  - импорт React обязателен, потому что в дальнейшем компонент превращается в
    React.createElement(), а его нет...
  - создаём ф-цию App [компоненты наз. строго с большой буквы]
  - в одном файле может быть только один компонент!
  - экспортируем по-дефолту
  - импортируем в index.js
    - т.к. мы под капотом используем webpack, то при импорте не нужно ставить
      расширение файла
  - рендерим App rfr обычный тег ReactDOM.render(<App />,
    document.getElementById("root"));
- обворачивать всё в строгий режим <React.StrictMode></React.StrictMode>, для
  выявления ошибок при разработке (при продакшине сам не работает)
- создаём файл Painting, а в нём компонент
  - теперь можем импортировать его в App.js

-------- React DevTools --------

- устанавливаем в браузер дополнение
- в ряде devtools появляются дополнительные вкладки Components и Profiler
  (удобно для отслеживания изменений)
- делаем компонент Painting динамическим
  - переносим наш template в Painting и видим ошибки, т.к. в области видимости
    нет указанных переменных и свойств объектов
  - нужно передать настройки (props) туда, где он рендерится (в App)
    - props - это объект, передающий в себе свойства

---

- пропсы передаются оттуда откуда рендарятся, а используются там, где
  шаблонятся: props => КОМПОНЕНТ => vDOM
- переносим из index.js в App.js наш объект-экземпляр painting

  - в App.Painting пишем типа свойства url и title
  - передаём Автора чем более плоский передаём пропс, тем проще работать с
    компонентом.
  - деструктуризируем принимаемые параметры пропса в Painting.js (и удаляем
    повторяющийся props.)
  - стрелочные ф-ции умеют возвращать неявный возврат, поэтому можем вернуть
    сразу выражение в скобках (мы возвращаем выражение снашей разметкой с общим
    родителем) - это нельзя будет сделать при добавлении состояния

--------------- JSON

- пробуем передать кусочки динамических объектов из бд
  - импортируем наш json с бд
  - вытираем вручную написанные данные в <Painting /> и вписываем дин.данные {}
- рендер по-условию (когда нужно что-то добавить)
  - используем тернарный оператор Имя: { - ? "true" : "false" } - можно вставить
    строку или выражение
- в react значения false, null, undefined - не рендарятся!

---

defaultProps --------------

- пишем в файле шаблонов дефолтные значения в случае, если не передаём нужные
  значения пропсов: Painting.defaultProps = {};
- в случае передачи дефолтного изображения лучше использовать стационарное, а не
  ссылку (время загрузки).
  - но просто прописать путь картинки в {./} - так не работает. Картинку
    необходимо импортировать, тогда через console.log() в консоли мы увидим
    реальный полный её путь: static/media/...jpg (можно вставить просто
    переменную при импорте в {})

------------- propTypes -------------

- специальный пакет-утилита, который может сообщить, какой тип данных нам пришел
  (ожидали строку, а пришел массив)
  - устанавливаем npm install --save-dev prop-types
  - все значения https://www.npmjs.com/package/prop-types
- import PropTypes from 'prop-types';
- все получаемые пропы описываем тут Painting.propTypes = {}.
- если проп обязательный, то пишем isRequired;
- если проп число, то передаём его в фигурных скобках {500}

------------ рендер коллекций --------------

- всё, что в jsx между открывающим и закрывающим тегом, воспринимается как
  строка
- если передаём массив отдельных значений, то рендерит каждое значение отдельно
  и последовательно
- если из данного массива элементов мы возвращаем каждый элемент в div и dblим,
  что возвращается то же количество реакт.элементов (массив объектов с
  реакт-элементами), то при рендере мы получим отдельное количество html
  элементов в div'ах {numbers.map((number) => <div>{number}</div>)}, т.е. для
  рендера динамических коллекций надо:
  - берем массив данных
  - .map'аем
  - и для каждого элемента возвращаем какую-то jsx-разметку
- поэтому для каждого входящего элемента массива из нашей бд мы будем возвращать
  наш компонент
  - массив данных - map - компонент.

----------- KEYS - это строчный атрибут -------------

- консоль ругается на отсутствие уникальных ключей, что должны быть созданы
  перед рендером (реакт не различает однотипные элементы, перерендерит всё),
  поэтому:
  - создаём 2й параметр .map index
  - задаём его динамически в атрибутах самого верхнего уникального элемента, что
    будет рендериться (у нас <li>)
    - index хорошее решение в случае, если коллекция не меняется, а только
      увеличивается, ноесли она меняется в случае удаления/вставки элементов, то
      она начинает ломаться (как только меняется ключ - ряд перерендеривает
      КОМПОНЕНТ)
    - лучше использовать id как ключ? они должны быть уникальны в одной
      коллекции, в разных могут повторяться
- в случае отсутствия id:
  - например цветовая коллекция - в роли ключа можно использовать сами же цвета,
    тк они будут уникальны

---------------- Список - это отдельный компонент ----------------

- создаём отдельный файл PaintingList.js
  - импорт реакт,
  - создаём шаблон с ul
  - экспортируем
  - импортируем в App PaintingList
  - ставим в div наш <PaintingList />, внутри которого мы хотим рендерить
    переданный нами ul, а значит переносим разметку из App в PaintingList
    - PaintingList ничего не знает о разметке Painting, а мы должны передать это
      как пропы, поэтому импортируем Painting в след за ul в файл PaintingList
    - прописываем атрибуты paintings={paintings}
    - переносим заглавие как отдельный компонент в Logo.js
      - экспортируем и импортируем в App.js
      - прописываем данные для входящего пропа
    - прописываем propTypes для каждого КОМПОНЕНТА
      - импортируем PropTypes
      - для PaintingList у нас только один проп и это массив
      - заходим в доки и смотрим как оформлять проптайп для массивов -
        - PropTypes.oneOf([1, 2]) - одно из 2х!
        - PropTypes.objectOf() - для объекта
        - PropTypes.exact({}) - для объекта, если точно знаем, что 1 в 1
        - PropTypes.shape({}) - для объекта
          - не PropTypes.objects - потому что слижком общий тип, не подходит
        - PropTypes.arrayOf() - для массива
          - внутри прописываем тип каждого элемента, который мы ожидаем, а
            ожидаем объект, поэтому .shape({сюда пишем id: и копируем все
            PropTypes из Paintings.js})
          - это дубляж, поэтому либо выносим в отдельный файл, либо не пишем,
            потому что уже проверяются и оставляем только id, который
            обязательный и весь массив тоже обязательный

------------ props.children ------------

- делаем панель как на Розетке
  - создаём файл Panel.js экспорт div
  - App import Panel
    - делаем открывающий и закрывающий теги, а внутри него абзац - он не
      рендерится, но показывается в компонентах как children
    - children возможен в случае, если он один, если их больше, то это уже
      массив
    - зарендерить его надо в самом Panel.js отправляя как пропс const Panel =
      (props) => <div> Панель {props.children} </div>;
    - добавляем title, деструктуризируем
    - добавляем стили
- в зависимости от наличия title делаем рендер по условию
  - логическое И (&&)
- проптайп и дефолтпропс
- когда хотим прописать проптайп чилдрен, то писать PropTypes.node и не
  заморачиваться

---

- дз
  - сказано какие КОМПОНЕНТЫ надо сделать
  - поднимаешь один проект
  - в папке components делаешь файлы, что указаны
  - потом все их рендеришь в одном App
    - импортируешь всё, что нужно
    - передаёшь пропы
    - прописываешь дефолты
    - прописываешь проптайпы
  - оформление не важно, важен синтаксис
