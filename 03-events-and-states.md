- для компонента, где динамические данные, ф-ции типа хуки не подходят
- компонент класса возвращает значение, но при этом state хранит динамические
  данные
- чтобы превратить ф-цию в класс, для вставки динамики нужно наследовать или
  расширять базовый компонент React.Components (extends)
- компоненты класса:
  - class
  - extends
  - сonstructor ()
  - render ()
- render () {return ()} должен возвращать только разметку!

--- инлайн колбеки

- события пишутся onСобытие
- в реакте уже реализовано глобальное делегирование x() => {}
- при передаче метода объекта как колбека в какой-то обработчик события, у
  объекта не привязывается контекст по-умолчани, поэтому объявляется публичное
  свойство через равно x = () => {}
- event работает только в синхронном коде, после снятия со стека (окончания
  ф-ции) он очищается, после выполненого действия setTimeout не сработает [null]
  setTimeot(() => { console.log(target); }, 1000);
- он сработает в случае, если сохранить свойство на объект в переменную const
  target = event.target

---

- работа с интерфейсом имеет замкнутый цикл
  - клик
  - обновление стека (объекта состояния)
  - обновляется интерфейс UI (React перерендерил)

6. - в олдскульном варианте

- constructor() { super (); - вызов конструктора родителя до this использования
  this.state = {}};
  - обязательно наз. state
  - обязательно внутри объект = {}
- появляется в devtools, где тоже можно изменять значение

7. т.к. под капотом Babel, конструктор можно не писать, а сразу объект state

8. НЕ ОБНОВЛЯТЬ СОСТОЯНИЕ ПО ССЫЛКЕ, записывая свойство или новый объект (для
   этого есть специальный метод)

9. this.setState ({});

- Цепочка обновления состояния
  - сделали метод для обн. сос.
  - зарегистрировали его на элементе
  - при клике (событии) вызвался метод
  - обновляется state
  - реакт перерендерил кусок кода с зарегестрированным методом

10. в случае, если у нас несколько свойств в state, то точно так же мы передаём
    только то, что хотим обновить, получается так:

- исходные значения currState
- обновлённое update
- и в конечном они распыляются накладываясь друг на друга в newState

11. 2й параметр коллбек (редко используется), вызывается, когда state обновится

12. неправильный вариант работы от предыдущего со ссылкой

- работает при одном значении, в случае нескольких операций выполняется только
  последняя
- потому что мы пытаемся обновить неактульное состояние, а состояние на момент
  регистрации

13. нужно создать ф-цию в которую будет приходить предыдущее состояние prevState
    и возвращать его значение prevState.value после чего работать с ним

- теперь работают несколько операций
- Итог:
  - не основываясь на предыдущем - это олбъект
  - основываясь - это ф-ция
  - начальное значение - от пропса
- в state создаётся новый объект

14. передаём дефолтный пропс для state

- в случае, если убрать this.props.initialValue то будет undefined, а при
  нажатии на ктнопки NaN, поэтому необходимо прописать дефолтное значение

15. с Babel можно писать в самом классе перед всем кодом до state через static

---

16. выносим разметку кнопок в отдельный компонент Controls

- рендерим внутри Counter.js
- проблема в том, что Controls не знает ф-ций {this.handleIncerment}
  - необходимо сделать подъём состояний

17. в Controls принимаем пропы onIncrement и onD., а в <Controls /> принимаем
    ссылку на атрибут
18. выносим Value в отдельный компонент и проделываем ту же операцию

---

- объяви state
- объяви методы, которые изменяют state
- передай ссылки на них в обработчики событий

19. Выпадающее меню (Dropdown)

- показывание и скрытие компонента в React
- создаём компонент и стили к нему
- создаём видимый state

20. добавляем методы для показа и прятания show и hide

21. можно использовать &&, т.к. если у visible: true, то рендерим, а если нет,
    то нет.

22. делаем toggle для облегчения. Рендер по условию. Этот метод 'от
    предыдущего', если false - то будет true.

- добавляем надпись по тому же принципу, если скрыто, то 'Показать'

---

23. оживляем Colorpicker - при нажатии будем хранить текущее значение
24. не знает что такое options, добавляем this.props.optons...
25. меняем span на button
26. - работая с массивом лучше хранить в значении индекс (а не имя или ещё
      что-то, так легче ссылаться)

- state может хранить только 1 объект и кучу методов работы с ним

27. прописываем state
28. даём дополнительный класс -- active

- узнаём текущий индекс при переборе в .map(({}, index))

29. инлайним стили и задаём условие сравнения, что если текущий индекс совпадает
    со state, то применяем стиль
30. нормально прописываем всё

- делаем базовый класс в массиве
- задаём условие при котором пушим доп. класс в массив
  - у активного индекса будет 2 класса (объеденяем через пробел .join(' '))

31. из-за сложности читабельности кода выносим это во внешнюю ф-цию ---
    Рефакторинг --- улучшать код
32. добавляем метод

- при клике по кнопке будет попытка вызвать undefined, поэтому
  onCilck={this.setActiveIdx(index)} не правильно писать, т.к. мы передаём вызов
  ф-ции (результат)
- передавать надо анонимную ссылку на ф-цию с index

---

33. вычисляемые данные (делаются в render перед return)

- определяем и пишем какой цвет выбран
- в state должно храниться минимальное количество данных, на основе которых
  сможем вычислить всё остальное
- у нас есть:
  - props с options
  - state с activeOptionIdx
    - можно взять по индексу объект со свойством цвета label
- сначала создаём переменную, назначаем ей данные, а потом деструктуризируем
  переменную и выделяем свойство label из этих данных

---

34. Паттерн

- деструктуризация state и props в методе render

Итог:

- использование индекса
- активный item
- вешанье кликов на коллекцию с передачей анонимной стрелки, вызовом метода и
  привязывания индекса

---

35. Re-export ()

- webpack ищет сначала файлы index.js. Выносим в него default export

---

36. коллекция заметок (работа с массивом):

- создание заметки
- удаление заметки состоит из:
- state хранит массив заметок
- список заметок, получаем props и рендерим их
- форма для создания заметок

- создаём index.js с default export и TodoList.js
- Todolist будет принимать проп из деструктуризированного свойства { todos }
- общий state компонентов хранится в общем родителе
  - в даном случае общим для todos будет App

37. создаём App class

- state
- деструктуризруем свойство { todos } = this.state

38. список todos
39. наполняем компонент TodoList
40. удаление заметок

- выносим наш массив данных во внешний json
- создаём кнопку удаления и стили ко всему
  - вешаем классы
- нужно создать метод, который удаляет заметку по нажатию на кнопку

41. - мы берём предыдущее состояние и на базе него делаем следующее (фильтруем
      все элементы, кроме совпадающего ID у todos, т.е. возвращаем все, которые
      не совпадают, а значит в новом масиве его не будет)
      - Используем на массивах map, filter, reduce, find (не используем push,
        slise, splise)
    - найти элементы (всегд ищем по ID)
42. привязываем onClick к buttton (не забывать про рендер)

---

43. вычисляемые данные (derived data) относительно наших заметок

- кол-во выполненных и невыполненных, общее и т.п.
- количество общее берем путём длинны массива todos
- количество выполненных можно взять:

44. - filter по complited, а потом length (массив закомпличенных тудушек)

- а можно методом reduce (главенствующий метод в React для подсчёта, а не для
  работы с массивом)
